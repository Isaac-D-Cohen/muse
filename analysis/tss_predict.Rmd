---
title: "Sequence composition and Random Forests"
date: "`r Sys.Date()`"
output:
  workflowr::wflow_html:
    toc: true
params:
  span: 2
  host: "https://asia.ensembl.org"
---

```{r setup, include=FALSE}
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
httr::set_config(httr::config(ssl_verifypeer = FALSE))
```

## Introduction

Transcriptional starting sites (TSSs) demarcate the first position in the DNA sequence that gets transcribed into RNA. In this work, we will build a Random Forest classifier that predicts whether a sequence of nucleotides is a TSSs or not. We will train our classifier using TSS sequences based on the NCBI Reference Sequence Database (RefSeq database). Building an accurate classifier will allow us to predict whether an unknown sequence is likely a TSS or not.

## Packages

First we'll define a function for loading required packages (and to install them first, if missing).

```{r load_package, message=FALSE, warning=FALSE}
load_package <- function(x, source = "bioc"){
  if(!require(x, character.only = TRUE, quietly = TRUE)){
    if (source == "bioc"){
      BiocManager::install(x, character.only = TRUE)
    } else if (source == "cran"){
      install.packages(x, character.only = TRUE)
    } else {
      stop("Unrecognised source")
    }
  }
  library(x, character.only = TRUE)
}
```

## RefSeq

We will use the Bioconductor package `biomaRt` to download the entire collection of RefSeq sequences.

```{r load_biomart}
load_package('biomaRt')
```

Find the human gene set.

```{r list_datasets}
ensembl <- useMart('ensembl', host = params$host)
biomaRt::listDatasets(ensembl) %>%
  filter(grepl('human', description, TRUE))
```

List RefSeq attributes for use with `getBM`.

```{r list_filters}
biomaRt::listDatasets(ensembl) %>%
  filter(grepl('human', description, TRUE)) %>%
  pull(dataset) -> my_dataset

ensembl <- useMart('ensembl', dataset = my_dataset, host = params$host)
listAttributes(ensembl) %>%
  filter(grepl('refseq', description, TRUE))
```

Fetch all RefSeq mRNA IDs on assembled chromosomes.

```{r fetch_refseq_mrna}
my_chr <- c(1:22, 'X', 'Y')

my_refseq <- getBM(
  attributes='refseq_mrna',
  filters = 'chromosome_name',
  values = my_chr,
  mart = ensembl
)

head(my_refseq)
```

Number of RefSeq IDs.

```{r number_refseq_id}
length(my_refseq$refseq_mrna)
```

We will perform another `getBM` query to build a table with the start and end coordinates of each mRNA/transcript. Note that when working with transcripts, use the attributes `transcript_start` and `transcript_end`, and not the attributes `start_position` and `end_position`; using those will give you the Ensembl gene coordinates and not the RefSeq coordinates, which is what we want! (I have retrieved the Ensembl coordinates for illustrative purposes.)

```{r my_refseq_loci}
my_att <- c(
  'refseq_mrna',
  'chromosome_name',
  'transcript_start',
  'transcript_end',
  'start_position',
  'end_position',
  'strand'
)

my_refseq_loci <- getBM(
  attributes = my_att,
  filters = c('refseq_mrna', 'chromosome_name'),
  values = list(refseq_mrna = my_refseq$refseq_mrna, chromosome_name = my_chr),
  mart = ensembl
)

dim(my_refseq_loci)
```

Check out the table.

```{r check_out_refseq_loci}
head(my_refseq_loci)
```

Check for duplicated entries.

```{r dup_refseq}
table(duplicated(my_refseq_loci$refseq_mrna))
```

Removed duplicated entries.

```{r remove_dup}
my_refseq_loci_uniq <- my_refseq_loci[!duplicated(my_refseq_loci$refseq_mrna),]
dim(my_refseq_loci_uniq)
```

We will modify `chromosome_name` and `strand` to make it compatible with `BSgenome.Hsapiens.UCSC.hg38`.

```{r add_chr_and_strand}
my_refseq_loci_uniq %>%
  mutate(strand = ifelse(strand == 1, yes = '+', no = '-')) %>%
  mutate(chromosome_name = sub("^", "chr", chromosome_name)) -> my_refseq_loci_uniq

head(my_refseq_loci_uniq)
```

## Transcription Start Site

The TSS is defined by `transcript_start` when the transcript is on the `+` strand and by `transcript_end` if the strand is `-`. We want to retrieve nucleotides upstream and downstream of the TSS, so we will subtract and add coordinates accordingly.

```{r tss_span}
my_tss <- list()

my_tss$loci <- my_refseq_loci_uniq %>%
  dplyr::select(-c(start_position, end_position)) %>%
  mutate(tss_start = if_else(strand == "+", transcript_start - params$span, transcript_end - params$span)) %>%
  mutate(tss_end = if_else(strand == "+", transcript_start + params$span, transcript_end + params$span))

head(my_tss$loci)
```

## Random loci

Non-TSS sequences will be generated by randomly sampling hg38, which is available via the `BSgenome.Hsapiens.UCSC.hg38` package.

```{r load_hg38, message=FALSE, warning=FALSE}
load_package('BSgenome.Hsapiens.UCSC.hg38')
```

Save chromosome names and their sizes.

```{r hg38}
hg38_ref <- seqnames(BSgenome.Hsapiens.UCSC.hg38)

# remove unassembled and mitochondrial sequences
hg38_chr <- hg38_ref[!grepl("_", hg38_ref)]
hg38_chr <- hg38_chr[!grepl("chrM", hg38_chr)]

hg38_chr_size <- sapply(hg38_chr, function(x){
  length(BSgenome.Hsapiens.UCSC.hg38[[x]])
})

head(hg38_chr_size)
```

Sample chromosome to match the number of TSSs.

```{r my_random_loci}
set.seed(1984)
n <- nrow(my_tss$loci)

sstrand <- sample(c("+", "-"), n, TRUE)
sstart <- sapply(my_tss$loci$chromosome_name, function(x){
  sample(hg38_chr_size[x] - (params$span * 2), 1)
})
send <- sstart + (params$span*2)

my_random <- list()

my_random$loci <- data.frame(
  chr = my_tss$loci$chromosome_name,
  start = sstart,
  end = send,
  strand = sstrand
)

head(my_random$loci)
```

## Removing overlaps

We will use the `GenomicRanges` package to remove randomly sampled regions that may have overlapped with TSS regions.

```{r load_genomic_ranges}
load_package("GenomicRanges")
```

First we will create a `GRanges` object using `my_refseq_loci`.

```{r my_tss_gr}
my_tss$gr <- with(
  my_tss$loci,
  GRanges(chromosome_name,
          IRanges(tss_start, tss_end, names = refseq_mrna),
          strand
  )
)

head(my_tss$gr)
```

Next we will create a `GRanges` object for the random loci.

```{r my_random_gr}
my_random$gr <- with(
  my_random$loci,
  GRanges(chr,
          IRanges(start, end, names = paste(chr, start, end, sep = "_")),
          strand
  )
)

head(my_random$gr)
```

The `countOverlaps` function will let us know the number of overlaps between random regions and TSSs.

```{r count_overlaps_gr}
table(countOverlaps(my_random$gr, my_tss$gr))
```

Remove overlapping random sites.

```{r random_loci_no_overlap}
my_random$loci_no <- my_random$loci[countOverlaps(my_random$gr, my_tss$gr) == 0, ]
dim(my_random$loci_no)
```

We will also check whether TSS regions overlap each other.

```{r count_overlaps_tss}
table(countOverlaps(my_tss$gr, my_tss$gr, minoverlap = 1))
```

We will also create a set of non-overlapping TSS regions (the conditional is `== 1` because we are comparing regions against itself and 1 is the self overlap), where a TSS does not overlap by a single bp.

```{r tss_loci_no_overlap}
my_tss$loci_no <- my_tss$loci[countOverlaps(my_tss$gr, my_tss$gr, minoverlap = 1) == 1, ]
dim(my_tss$loci_no)
```

## Sequence

At this point, we have our TSS and random coordinates but we are missing the nucleotide sequences that correspond to the defined coordinates. The `getSeq` function can be used to fetch the sequence.

```{r random_seq}
my_random$seq <- getSeq(
  BSgenome.Hsapiens.UCSC.hg38,
  names = my_random$loci$chr,
  start = my_random$loci$start,
  end = my_random$loci$end,
  strand = my_random$loci$strand
)

head(my_random$seq)
```

Remove entries with N's.

```{r remove_n}
my_random$seq <- my_random$seq[! grepl("N", my_random$seq)]
head(my_random$seq)
```

Obtain TSS sequences.

```{r tss_seq}
my_tss$seq <- getSeq(
  BSgenome.Hsapiens.UCSC.hg38,
  names = my_tss$loci$chromosome_name,
  start = my_tss$loci$tss_start,
  end = my_tss$loci$tss_end,
  strand = my_tss$loci$strand
)

my_tss$seq <- my_tss$seq[! grepl("N", my_tss$seq)]
head(my_tss$seq)
```

Obtain non-overlapping TSS sequences.

```{r my_tss_seq_non_overlap}
my_tss$seq_no <- getSeq(
  BSgenome.Hsapiens.UCSC.hg38,
  names = my_tss$loci_no$chromosome_name,
  start = my_tss$loci_no$tss_start,
  end = my_tss$loci_no$tss_end,
  strand = my_tss$loci_no$strand
)

my_tss$seq_no <- my_tss$seq_no[! grepl("N", my_tss$seq_no)]
head(my_tss$seq_no)
```

The `dinucleotideFrequency` function can be used to calculate the di-nucleotide frequency given a sequence string.

```{r di_freq}
my_random$di <- dinucleotideFrequency(my_random$seq)
colSums(my_random$di)

my_tss$di <- dinucleotideFrequency(my_tss$seq)
colSums(my_tss$di)

my_tss$di_no <- dinucleotideFrequency(my_tss$seq_no)
colSums(my_tss$di_no)
```

Plot di-nucleotide frequencies between TSS and random regions.

```{r plot_di}
my_df <- data.frame(
  x = colMeans(my_tss$di),
  y = colMeans(my_random$di),
  di = colnames(my_tss$di)
)

ggplot(my_df, aes(x, y, label = di)) +
  geom_point() +
  geom_text(nudge_x = 0.005) +
  geom_abline(slope = 1, lty = 3) +
  labs(x = "TSS", y = "Random") +
  theme_bw()
```

Plot di-nucleotide frequencies between overlapping and non-overlapping TSS regions.

```{r plot_di_tss}
my_df <- data.frame(
  x = colMeans(my_tss$di),
  y = colMeans(my_tss$di_no),
  di = colnames(my_tss$di)
)

ggplot(my_df, aes(x, y, label = di)) +
  geom_point() +
  geom_text(nudge_x = 0.005) +
  geom_abline(slope = 1, lty = 3) +
  labs(x = "TSS", y = "TSS no overlap") +
  theme_bw()
```

## Random Forests

A Random Forest classifier generally performs well and we will use it to train a model to predict whether a sequence is a TSS or not based on di-nucleotide frequencies.

```{r load_random_forest, message=FALSE, warning=FALSE}
load_package('randomForest', source = "cran")
```

Combine TSS and random data. (We saw that overlapping and non-overlapping TSSs had similar di-nucleotide frequencies, so we will use the overlapping set.)

```{r create_my_data}
as.data.frame(my_tss$di) %>%
  mutate(class = 'tss') -> my_data

as.data.frame(my_random$di) %>%
  mutate(class = 'random') %>%
  rbind(my_data) %>%
  mutate(class = factor(class)) -> my_data

dim(my_data)
```

Check out `my_data`.

```{r check_out_my_data}
my_data[c(1:3, (nrow(my_data)-2):(nrow(my_data))), ]
```

Split 80/20.

```{r train_and_test_data}
set.seed(1984)
idx <- sample(nrow(my_data), nrow(my_data)*0.8)

train <- my_data[idx, ]
test <- my_data[-idx, ]

prop.table(table(train$class))
prop.table(table(test$class))
```

Train Random Forest.

```{r random_forest}
my_rf <- randomForest(
  class ~ .,
  data = train,
  importance = TRUE,
  do.trace = 100,
  ntree = 500
)

my_rf
```

Train using more features.

```{r random_forest_mtry}
my_rf_6 <- randomForest(
  class ~ .,
  data = train,
  importance = TRUE,
  do.trace = 100,
  ntree = 500,
  mtry = 6
)

my_rf_6
```

Feature importance.

```{r importance}
rn <- round(importance(my_rf), 2)
rn[order(rn[,3], decreasing=TRUE),]
```

Plot feature importance.

```{r importance_plot}
varImpPlot(my_rf)
```

Use our Random Forest classifier to make predictions on the test data.

```{r predict}
data.predict <- predict(my_rf, test)
prop.table(table(observed = test$class, predict = data.predict), 1)
```

Use `pROC` package to calculate the area under the ROC curve.

```{r load_proc, message=FALSE, warning=FALSE}
load_package("pROC", source = "cran")
```

Area under the ROC curve.

```{r roc}
roc(my_rf$y, my_rf$votes[, 'random'])
```

Plot ROC with the `verification` package.

```{r load_verification, message=FALSE, warning=FALSE}
load_package('verification', source = "cran")
```

Plot ROC.

```{r plot_roc}
aucc <- roc.area(as.integer(train$class=='tss'), my_rf$votes[,2])$A
roc.plot(as.integer(train$class=='tss'), my_rf$votes[,2], main="")
legend("bottomright", bty="n", sprintf("Area Under the Curve (AUC) = %1.3f", aucc))
title(main="OOB ROC Curve Random Forest for predicting TSS")
```

### Nucleotide frequency across TSS

The di-nucleotide frequencies were useful in predicting TSSs but we lost the positional information of each di-nucleotide and the relative position of a di-nucleotide may be important.

To confirm this, we can use the `nucleotideFrequencyAt` function to return the single nucleotide frequency at a specific location.

```{r nuc_freq_at}
nucleotideFrequencyAt(x = my_tss$seq, at = 3)
```

We will use `sapply` to calculate the nucleotide frequencies at all sites.

```{r nuc_freq_at_all}
nuc_freq <- sapply(1:((params$span*2)+1), function(x) nucleotideFrequencyAt(my_tss$seq, x))

nuc_freq_norm <- apply(nuc_freq, 2, function(x) x/sum(x))
colnames(nuc_freq_norm) <- c('m2', 'm1', 't', 'p1', 'p2')

nuc_freq_norm
```

There is a higher CT (pyrimidine) ratio one position before the TSS (`m1` [minus 1] column) and a higher AG (purine) ratio at the TSS (`t` column) forming the classic pyrimidine–purine (PyPu) di-nucleotide at a TSS.

Given this positional bias, we will calculate di-nucleotide frequencies at all positions using the `dinucleotideFrequency` function.

```{r dinuc_freq}
dinuc_freq_tss <- lapply(1:(params$span*2), function(x){
  dinucleotideFrequency(subseq(my_tss$seq, x, x+1))
})

dinuc_freq_random <- lapply(1:(params$span*2), function(x){
  dinucleotideFrequency(subseq(my_random$seq, x, x+1))
})

dinuc_freq_tss_df <- do.call(cbind.data.frame, dinuc_freq_tss)
dinuc_freq_random_df <- do.call(cbind.data.frame, dinuc_freq_random)

my_colname <- paste0(
  'X',
  rep(1:(params$span*2), each = 16),
  "_",
  colnames(dinuc_freq_tss_df)[1:16]
)

colnames(dinuc_freq_tss_df) <- my_colname
colnames(dinuc_freq_random_df) <- my_colname

head(dinuc_freq_tss_df)
```

Combine TSS and random data.

```{r create_my_data2}
dinuc_freq_tss_df %>%
  mutate(class = 'tss') -> my_data2

dinuc_freq_random_df %>%
  mutate(class = 'random') %>%
  rbind(my_data2) %>%
  mutate(class = factor(class)) -> my_data2

saveRDS(object = my_data2, file = "data/tss.rds")

dim(my_data2)
```

Split 80/20.

```{r train_and_test_data2}
set.seed(1984)
idx <- sample(nrow(my_data2), nrow(my_data2)*0.8)

train2 <- my_data2[idx, ]
test2 <- my_data2[-idx, ]

dim(train2)
dim(test2)
```

Train Random Forest.

```{r random_forest2}
my_rf2 <- randomForest(
  class ~ .,
  data = train2,
  importance = TRUE,
  do.trace = 100,
  ntree = 500
)

my_rf2
```

Feature importance.

```{r importance2}
rn2 <- round(importance(my_rf2), 2)
head(rn2[order(rn2[,3], decreasing=TRUE),])
```

Feature importance plot.

```{r importance_plot2, fig.height=8, fig.width=5}
varImpPlot(my_rf2)
```

Compare prediction results of our first model and our second model.

```{r predict2}
# results from first model
data.predict <- predict(my_rf, test, type = "vote")
auroc <- roc.area(as.integer(test$class=='tss'), data.predict[,2])$A
roc.plot(as.integer(test$class=='tss'), data.predict[,2], main="ROC")
legend("bottomright", bty="n", sprintf("Area Under the Curve (AUC) = %1.3f", auroc))

# results from second model
data.predict2 <- predict(my_rf2, test2, type = "vote")
auroc2 <- roc.area(as.integer(test2$class=='tss'), data.predict2[,2])$A
roc.plot(as.integer(test2$class=='tss'), data.predict2[,2], main="ROC")
legend("bottomright", bty="n", sprintf("Area Under the Curve (AUC) = %1.3f", auroc2))
```

By including the positional information of the di-nucleotides, we have a better TSS classifier, which makes sense since not all the bases upstream and downstream of the TSS have a nucleotide preference and thus were diluting the signal in our first model where we calculated the overall di-nucleotide frequency.
